// An OSL implementation of Hex-Tiling, as shown by Mikkelsen in "Practical Real-Time Hex-Tiling"
// adl_HexTile_semiType.osl, by Andrew Louda
// Modified: 2023-02-14
// Copyright 2023 Andrew Louda. This file is licensed under the Apache 2.0 license.
// SPDX-License-Identifier: Apache-2.0

// Special care needs to be taken with Hex-Tiling normal maps which is currently not possible in OSL (more specifically in Redshift's version). Details are in the appropriate section.
// This version makes use of the inbuilt vec2 and vec4 semi-types provided with OSL, though I still use the vector-based rotate function

#define vec3 vector
#include <vector2.h>
#define vec2 vector2
#include <vector4.h>
#define vec4 vector4

#define sqrt_3x2 3.46410161514

vec2 spin( vec2 coord, float rad){
    vector stv = rotate( vector(coord.x, coord.y, 0), rad, {0,0,1});
    return vec2(stv.x,stv.y);
}

//Applies the 4 components of a 2x2 matrix to a vector, passing through the z component
vec2 apply2Dm( vec4 trans, vec2 val){
    return vec2( trans.x*val.x + trans.y*val.y, trans.z*val.x + trans.w*val.y);
}

// Produce an arbitrary offset from a hex tile center
vec2 custom_hash( vec2 in_vertex){
    vec2 shift_val = sin( apply2Dm( vec4(127.1, 311.7, 269.5, 183.3), in_vertex)) * 43758.5453;
    vec2 valfloor = floor( shift_val);
    return (shift_val - valfloor);
}

// Remap an integer hex tile center to st space.
vec2 make_cen( vec2 in_vertex){
    vec2 step1 = apply2Dm( vec4(1.0, 0.5, 0.0, 0.86602505756), in_vertex);
    return step1 / sqrt_3x2;
}

// This differs from the paper's implementation in that it relies on OSL's inbuilt rotate() function,
// instead of creating and applying a transformation matrix. This value is passed to rotate() later on.
float rotamp( vec2 idx, float rad){
    float angle = abs(idx.x*idx.y) + abs(idx.x+idx.y) + M_PI;

    // Remap to +/-pi
    angle = fmod(angle, M_2PI);
    if(angle<0) angle += 2*M_PI;
    if(angle>M_PI) angle -= M_2PI;

    return angle * rad;
}

// Apply an S-curveâ€“shaped ramp to the signal and normalize the weights.
vector Gain3(vector x, float r){
    // Increase contrast when r > 0.5 and
    // reduce contrast if less.
    float k = log(1-r) / log(0.5);
    vector s = 2*step(0.5, x);
    vector m = 2*(1 - s);
    vector res = 0.5*s + 0.25*m * pow(max(0.0, s + x*m), k);
    return res / (res.x+res.y+res.z);
}

// Swizzle the weights to produce a consistent hex color for visualization purposes.
vector ProduceHexWeights(vector W, vec2 vertex1, vec2 vertex2, vec2 vertex3){
    vector res = 0.0;
    int v1 = int(vertex1.x-vertex1.y)%3;
    if(v1<0) v1+=3;
    int vh = v1<2 ? (v1+1) : 0;
    int vl = v1>0 ? (v1-1) : 2;
    int v2 = vertex1.x<vertex3.x ? vl : vh;
    int v3 = vertex1.x<vertex3.x ? vh : vl;
    res.x = v3==0 ? W.z : (v2==0 ? W.y : W.x);
    res.y = v3==1 ? W.z : (v2==1 ? W.y : W.x);
    res.z = v3==2 ? W.z : (v2==2 ? W.y : W.x);
    return res;
}

shader adl_hextile(
    vector uvcoords = vector(u,v,0),
    string texpath = "" 
        [[string widget = "filename"]],
    int is_normal = 0
        [[int min = 0, int max = 1, string widget = "boolean"]],
    float tex_scale_uni = 1
        [[float min = 1, float max = 16]],
    vector tex_scale = 1,
    vector tex_offset = 0,
    float tex_rotate = 0
        [[float min = 0, float max = 360]],
    float rotStrength = 0
        [[float min = 0, float max = 180]],
    float rcurve = 0.6
        [[float min = 0.5, float max = 0.95]],    
    output color colout = 0,
    output color weightout = 0,
)
{
    float radStrength = radians(rotStrength);

    // Modification of input coordinates
    vec2 st = vec2(uvcoords[0], uvcoords[1]) * tex_scale_uni * vec2(tex_scale.x,tex_scale.y);
    st.x += tex_offset.x, st.y += tex_offset.y;
    vector stv = 0;
    if(tex_rotate !=0) st = spin( st, radians(tex_rotate));
    
    //TriangleGrid
    vec2 skew_st = st*sqrt_3x2;
    skew_st = apply2Dm( vec4(1.0, -0.57735027, 0.0, 1.15470054), skew_st);
    vec2 baseId = floor(skew_st);
    vector tempval = vector(skew_st.x - baseId.x, skew_st.y - baseId.y, 0);
    tempval[2] = 1.0 - tempval[0] - tempval[1];
    
    float s = step(0.0, -tempval[2]);
    float s2 = 2*s-1;
    
    // Hex tile weights
    float w1 = -tempval[2]*s2;
    float w2 = s - tempval[1]*s2;
    float w3 = s - tempval[0]*s2;
    
    // Integer centers
    vec2 vertex1 = baseId + vec2(s,s);
    vec2 vertex2 = baseId + vec2(s,1-s); 
    vec2 vertex3 = baseId + vec2(1-s,s);
    
    // Hex tile sampling

    //vector dSTdx = Dx(st), dSTdy = Dy(st);

    // Rotate each individual hex tile around it's center
    float rot1 = rotamp(vertex1, radStrength), rot2 = rotamp(vertex2, radStrength), rot3 = rotamp(vertex3, radStrength);
    vec2 cen1 = make_cen(vertex1), cen2 = make_cen(vertex2), cen3 = make_cen(vertex3);
    vec2 st1 = spin(st-cen1, rot1)+cen1+custom_hash(vertex1);
    vec2 st2 = spin(st-cen2, rot2)+cen2+custom_hash(vertex2);
    vec2 st3 = spin(st-cen3, rot3)+cen3+custom_hash(vertex3);

    vector f1, f2, f3, weights;
    
    if(is_normal){
        // The variant of this meant to handle rotated normal maps relies on a function called SampleGrad, which samples a texture along a gradient.
        // I'm not as of yet aware of how to implement this, as it requires derivatives, which Redshift does not support (3.5.13)
        // the following colors are output simply so that it is clear that the shader is functioning.
        f1 = vector(1,0,0), f2 = vector(0,1,0), f3 = vector(0,0,1);
        weights = 0;
    }
    else{
        // Fetch input
        f1 = texture( texpath, st1.x, st1.y);
        f2 = texture( texpath, st2.x, st2.y);
        f3 = texture( texpath, st3.x, st3.y);
        // Use luminance as weight.
        vector Lw = {0.299, 0.587, 0.114};
        weights = vector(dot(f1,Lw),dot(f2,Lw),dot(f3,Lw));
    }
    weights = mix(1.0, weights, 0.6);
    vector W = weights*pow(vector( w1, w2, w3), 7);
    W /= (W.x+W.y+W.z);
    if(rcurve!=0.5) W = Gain3(W, rcurve);

    // Final combination using weighted values
    colout = W.x * f1 + W.y * f2 + W.z * f3;
    weightout = ProduceHexWeights(W, vertex1, vertex2, vertex3);
}