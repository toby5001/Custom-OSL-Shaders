// Inspired by the post-processing system that comes with the maxon noise system. This allows for per-shading-point variation and use outside of maxon noise.
// adl_mxPost.osl, by Andrew Louda
// Modified: 2024-07-22 - Cleaned up code
// Copyright 2022 Andrew Louda. This file is licensed under the Apache 2.0 license.
// SPDX-License-Identifier: Apache-2.0

// When using color in an original maxon noise, it appears to output a greyscale value, to which the colors are then applied. Since this code can't get between those processes, it is recommended to use a greyscale input in combination with a gradient map or color mix for identical behavior.
// Depending on how OSL optimizes things when compiling, disabling either the float or vector output may see a slight performance gain
// #define enable_color

float fit(float valin, float InStart, float InEnd, float OutStart, float OutEnd){
    float fac = (clamp(valin,InStart,InEnd) - InStart) / (InEnd - InStart);
    return OutStart + fac * (OutEnd - OutStart);
}

float mx_Cycle(float In, float fmodval, float cycles_phase, int smoothcycles){
    float outval;
    float fmod_setup(float In, float fmodval){ return (fabs(fmod(In+cycles_phase/fmodval*2.0,1.0/(fmodval*0.5))*(fmodval*0.5))); }
    float rerange(float val){ return 1-(fabs(val-0.5)*2.0); }
    //This is not a pixel-perfect match with the smoothing used within maxon noise's cycles, but it's incredibly close. This function is seemingly identical to the inbuilt smoothstep function.
    float BezierBlend(float t){ return t * t * (3.0 - 2.0 * t); }
    if(fmodval >= 1){
        outval = fmod_setup( In, fmodval);
        outval = rerange(outval);
        if(smoothcycles){
            outval = BezierBlend(outval);
        }
    }
    else{
        outval = fmod_setup( In, 1);
        outval = rerange(outval);
        if(smoothcycles){
            outval = BezierBlend(outval);
        }
        outval = mix(In, outval, fmodval);
    }
    return outval;
}

float mx_Clip(float colorcomp, float lowclip, float highclip){
    float Out;
    if(lowclip == highclip){
        Out = colorcomp>=lowclip?1:0;
    }
    else{
        Out = fit(colorcomp, lowclip, highclip, 0, 1);
    }
    return Out;
}

float mx_Brightness(float In, float brightness){
    float Out = clamp(In + brightness, 0, 1);
    return Out;
}

float mx_Contrast(float colorcomp, float contrast){
    float colorout;
    if(contrast==1){
        colorout = colorcomp>=0.5?1:0;
    }
    else if(contrast>0){
        float distance = (1-contrast)/2;        
        colorout = fit(colorcomp, 0.5-distance, 0.5+distance, 0, 1);
    }
    else if(contrast==-1){
        colorout = 0.5;
    }
    else if(contrast<0){
        float distance = (contrast*-1)/2;
        colorout = fit(colorcomp, 0, 1, 0+distance, 1-distance);
    }
    return colorout;
}

shader Mx_Post(

    #ifdef enable_color
        color ColorIn = 0,
    #else
        float FloatIn = 0,
    #endif

    float cycles = 0
    [[  float slidermin = 0, float slidermax = 10,
        string label = "Cycles"]],

    float cycles_phase = 0
    [[  float slidermin = -1, float slidermax = 1,
        string label = "Cycles Phase"]],

    int   smoothcycles  = 1 
    [[  string widget= "checkBox",
        string label = "Smooth Cycles"]],

    float lowclip = 0 
    [[  float min = 0, float max = 1,
        string label = "Low Clip"]],

    float highclip = 1 
    [[  float min = 0, float max = 1,
        string label = "High Clip"]],

    float brightness = 0 
    [[  float min = -1, float max = 1,
        string label = "Brightness"]],

    float contrast = 0 
    [[  float min = -1, float max = 1,
        string label = "Contrast"]],
    
    #ifdef enable_color
        output color ColorOut = 0,
    #else
        output float FloatOut = 0,
    #endif
    )
{
    float post_per_component(float In){
        float Value = In; 
        if(cycles>0){
            Value = mx_Cycle(Value,cycles,cycles_phase,smoothcycles);
        }
        if(lowclip > 0 || highclip < 1){
            Value = mx_Clip(Value,lowclip,highclip);
        }
        if(brightness != 0){
            Value = mx_Brightness(Value,brightness);
        }
        if(contrast != 0){
            Value = mx_Contrast(Value,contrast);
        }
        return Value;
    }

    #ifdef enable_color
        int i = 0;
        for(i = 0 ; i < 3; ++i) {
            ColorOut[i] = post_per_component(ColorIn[i]);
        }
    #else
        FloatOut = post_per_component(FloatIn);
    #endif
}